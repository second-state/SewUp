initSidebarItems({"enum":[["Error","Ways that a script might fail. Not everything is split up as much as it could be; patches welcome if more detailed errors would help you."],["Instruction","A “parsed opcode” which allows iterating over a Script in a more sensible way"]],"fn":[["read_scriptbool","This is like “`read_scriptint` then map 0 to false and everything else as true”, except that the overflow rules don’t apply."],["read_scriptint","Helper to decode an integer in script format Notice that this fails on overflow: the result is the same as in bitcoind, that only 4-byte signed-magnitude values may be read as numbers. They can be added or subtracted (and a long time ago, multiplied and divided), and this may result in numbers which can’t be written out in 4 bytes or less. This is ok! The number just can’t be read as a number again. This is a bit crazy and subtle, but it makes sense: you can load 32-bit numbers and do anything with them, which back when mult/div was allowed, could result in up to a 64-bit number. We don’t want overflow since that’s surprising — and we don’t want numbers that don’t fit in 64 bits (for efficiency on modern processors) so we simply say, anything in excess of 32 bits is no longer a number. This is basically a ranged type implementation."],["read_uint","Read a script-encoded unsigned integer"]],"struct":[["Builder","An object which can be used to construct a script piece by piece"],["Instructions","Iterator over a script returning parsed opcodes"],["Script","A Bitcoin script"]]});